      讲到面向对象，要看一个引用类型这个概念。每个对象都是基于引用类型创建的。


      那可以说引用类型都是对象，object、函数、数组、甚至是null，可以用typeof来检查数据类型，比如我们在写代码中常常会做条件判断：

      比如封装简单的getElementById(“id”)函数来说，可以用这样的写法：
    
        var $=function(id){
        return typeof id ===”string”?getElementById(id):id;
        }
    （有没有像jQ？）上面就用了typeof来检测数据类型来进行接下来的操作。

      那引用类型，它真是除了属性还是属性， 包括函数的方法其实也是属性，只不过表现的形式不同罢了。

     但是出现了一个比较有意思的地方，那就是对象都是函数创建的，而函数又是一种对象，真是厉害了。比如var array =[0,1,2]，
    这是个数组啊，其实并不是这么简单，上面是一种缩写，其实详细的写法是  
    
      var arr=New Array(); arr[0]=0;arr[1]=;arr[2]=2;
    
      而typeof(Array)  就是function，没错，控制台可以打一下看看
    所以喽，所有的对象都属通过函数来创建的。

      说到函数，每个函数都有一个prototype属性，用来指向它的原型，而原型可以看作具有多个属性的集合，而这个集合中有一个
    constructor属性，指向函数本身的，也就是说函数自带一个属性prototype指向一个原型，而这个原型又自带一个constructor来指向这个函数。

    这么做的好处就是可以为函数原型添加属性，然后让这个函数或者实例化对象用这些属性。

      比如new一个新的对象，一般把new出来的新对象称之为实例。这个实例对象自带_proto_属性，这个属性指向创建该对象函数中的prototype，也
    就是指向创建这个实例对象函数的原型。而通过对象字面量方法创建出来的对象。默认指向object的原型，而这个object的_proto_其实指向为null；

     上面说到对象都是函数创建的，那么对象有_proto_，函数是被函数创建的，当然也有，函数的_proto_属性指向哪里呢？比如：

      var fn=new Function()

     那按照对象的思路来，函数也有_proto_，它指向Function.prototype。总结一下，对象是通过函数创建的，函数也是通过函数创建的，那么他们
    都有_proto_，都指向创建它们的那个函数的原型。但是它们最终都指向Object的原型（终极爸爸）。

      铺垫这么多该引入了一个主角了instanceof，数据类型分为两类，一种为基本数据型、另一种是引用类型，而检测这两种，我们可以用typeof，
    有string、number、boolean、undefined、object、function，但是想知道对象是什么类型的，就要用到了instanceof。列出几个乱例子：

      Object instanceof Function == true
      Function instanceof Function == true
      Function instanceof Object == true

      有点乱，但是为什么会这样，正如我上面说的，对象是函数创建的，函数也是函数创建的，函数也是对象。梳理这些之前先看一下instanceof 
    的工作原理。instanceof 左边和右边，根据他们对应的_proto_去向上找，如果同时指向一个原型，则会返回true。也就是上面的总结，函
    数创建了对象，函数创建了函数，对象指向了函数，函数指向了对象。估计晕了。而这就引出了继承和原型链的概念。

     用原型链来继承是最好不过的了，当一个对象没有对应的该属性时，就会沿着原型链向上找，确定一个属性是自身的还是原型上的，就可以
    用hasOwnProperty()方法检测，而这个方法（属性）每个对象都有，因为它是继承的（继承多么强大），它取自于Object.prototype。

    这样做的好处就是可扩展性很好，可以自己加属性，然后让子代都可以继承，比如我最近写的组件开发的简历模板就用了这个思路(JQ的extend)。
  
      简单总结下：对象是函数创建的，每个函数都有prototype属性，该属性指向一个包含constructor属性的原型对象，而函数又都是对象，对
    象又带_proto_属性，所以可以通过这个属性来继承一些原型对象上的属性，也可以在原型对象上自定义属性来让子代继承。检测数据类型可
    以用typeof，检测什么类型的对象可以用instanceof 。
