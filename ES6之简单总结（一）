这两天又把ES6看了下，简单总结一下。把新的特性有几句话概括一下，加深自己的印象
  1．let和const命令
  
  （1）let
  
  let用来声明变量，其声明的变量只在其所在的代码块中有效，代码块之外访问不到，举例：

    for(var i=0; i<10 ;i ++){  
      a[i]=function(){
        console.log(i)
        }
      }

    a[5]()   // 10

  之所以是输出10，是var声明的变量，它在下一次运行的结果会保存在内存中，然后覆盖掉之前的值，所以到最后保留了最终值，也就是10；

  而同样的方法要是用let声明的话，则会输出5，因为let声明的变量只会在当轮循环有效，相当于每一次都声明了一个新的变量，保存了下来

  必须要先声明，后使用变量（无法变量提升）
  
  只要在代码块中使用了let声明变量，那么这个代码块会形成块级作用域，所以就需要在使用变量前，先声明（暂时性死区）
不允许在块级作用域中重复声明一个变量，否则会报错

  （2）块级作用域
  
  可以在块级作用域中声明函数，而在块级作用域中声明的函数，外部是无法访问到的
  
  当然函数声明和变量声明都在块级作用域内才有效了，要返回给外部可以在块级作用域的花括号前加上 do，让它变为表达式
  
  （3）const
  
  声明只读的常量，一旦声明不能修改，否则会报错 ，而且必须要初始化
  
  const和let类似，都有无法变量提升、不可重复声明、暂时性死区的特性
  
  （4）顶层对象属性
  
  let和const声明的全局变量，不再属于window的属性了
  
  2．变量和解构赋值
  
  （1）数组解构赋值
  
  左右都有变量和数值的情况下
  等式左右两边相等，那么会对应赋值；如果右边少的话，对应左边的变量会为undefined，这种叫做解构（左边多、右边少||左右相等）
  还有不完全解构（左多又少），那么左边会对应解构，剩下的右边值不会去用

  左边变量有默认值的情况下
  如果右边的值 严格等于===  undefined，那么会使用左边变量的默认值，否则如果右边的值不严格等于undefined，那么左边的变量不管有没有默认值都会解构
  
  （2）对象的解构赋值
  无次序，只要变量名与属性名一致即可
  使用let或const声明变量，必须在下面解构的时候，把需要解构的对象放在另一个代码块中，要不然会出现let、const重复声明的报错现象
  可以使用默认值，右边对应值为undefined的话，会使用默认值
  如果变量声明过了，下面的解析需要用括号包起来

  （3）其它解析
  
  只要等号右边不是对象（包括数组），那么将其转化为对象再解析，调用tostring方法，undefined和null解析会报错
  
  3．数组
  
  （1）Array.form转换数组
  将类似数组的对象和可遍历的对象转换为数组，类似数组的对象本质上就是带有length属性，然后可以让其拥有数组的方法，比如map、foreach等等
  还可以接受一个参数，例如对第一个参数进行处理的函数
  
  （2）Array.of
  类似于数组字面量，直接把后面的参数，转换为数组内的值
  
  （3）find和findIndex
  find后接一个回调函数，如果符合条件就把对应的值返回
  findIndex和find类似，如果符合条件就把对应值的索引返回出来
  
  （4）fill填充数组
  fill后面接参数，把参数填到数组里，也可以指定起始和终止的位置
  
  （5）遍历的方法
  
  遍历键：values()
  遍历值：keys()
  遍历键值对：entries()
  
  4．函数的扩展
  （1）函数传参可以指定默认值
  
  原始当在函数内，想让参数等于传入的值或者默认值的话需要 
  
    function fn (a ){
    a= a || b; //传入a的值就用a，否则就用b
    }
    
  现在可以直接在参数内添加默认值了，可上面的效果是一样的，例如:
  
    function fn (a=b){ }

  但是这样就相当于声明了a，所以函数体内不用再次声明即可

  （2）参数的默认值：
  
  如果在函数传参的时候，为其中一个设置默认值，那么这个参数就叫做尾参数；

  只要尾参数不是函数传参中的最后一个参数，那么调用该函数传参的时候，不能忽略当前位置的参数，最少也要写undefined，例如

    function fn(x=1,y){
    return [x,y]
    }

  这里的x就是尾参数，它不是函数最后一个参数，函数最后一个参数是y，加入调用的话

    fn(2) =>> [2,undefined]
    fn(,2) =>> 报错，因为尾参数那个位置未传值
    fn(undefined,2) =>> [1,2] 

  带有默认值的参数，如果尾参数是最后一个参数，那么函数的length就减去1；
  如果尾参数不是最后一个参数的话，那么它连它之后的参数都不算在函数的length内

  （3）rest参数
  
  (...变量名)，把这个当函数的参数传入，可以省略传入多次参数；这个变量名用来保存数组；

  rest参数后不能再有别的参数，但是之前可以有参数，当然rest参数也不算在函数的length中

  与之相似的是扩展运算符 ...[a,b,c]，这回传入的不是变量名，而是用逗号分隔的数组，其实和apply类似，apply也是把参数以数组的形式传入

  这个功能很强大，比如合并数组，简便传参，都很实用
  
  （4）name属性
  
  调用函数的name属性，返回这个函数名，包括声明的函数、函数表达式
  
  （5）箭头函数 =>
  
  参数 => 代码块执行的内容

  返回多个语句，则箭头后面有 { } 包裹起来

  返回对象的话，则用 （）包裹起来

  但是这个箭头函数内的this是绑定的是定义时候的作用域，且不能用构造函数new对象实例

  （6）this指向
  
  刚才说了箭头函数内是没有自己的this的，它是用的定义它的那个对象的this，也就是箭头函数内用call,apply,bind都无法改变执行上下文环境了。

  （7）尾递归
  
  函数内部最后返回另一个函数，这个函数不进行任何运算，但是可以传参

  可以尾递归优化，就是多传入参数，让参数在函数内部进行运算

  最后还是建议，把尾递归写成函数判断返回式，可以节省内存

  5．对象的扩展
  
  （1）简写
  
  可以把属性简写：把属性值覆给变量，然后字面量中只传入该变量名
  方法简写：可以省去:function, 其他不变

  可以在对象字面量中使用[ ]包裹的属性名，且如果该属性值为对象的话，默认后面覆盖前面的

  （2）Object.is()
  
  同值相等，类似于 ===
  但是ES5中 ：+0 全等于 -0 ，NaN 不等于 NaN 
  用这个方法的话：+0 不等于 -0 ，NaN 全等于 NaN 
  
  （3）Object.assign()合并对象
  
  同名属性会覆该，浅拷贝（遇到同名属性是替换，不是添加）

  参数不是对象会转换为对象，字符串会以数组的形式合并进去，布尔值和数值不会合并

  不拷贝继承属性和不可枚举的属性

  利用这个方法可以为 对象添加属性和方法，合并多个对象
  
  （4）遍历属性
  
  for in 遍历自身和继承可枚举的属性
  Object.keys() 遍历自身可枚举的属性
  Object.getOwnPropertyNames(obj) 遍历自身所有属性
  （5）几大方法
  Object.setPrototypeof(obj,prototype) 为obj添加原型prototype

  Object.getPrototypeof(obj) 读取这个对象的原型

  和遍历数组的方法很像的是

  Object.keys()  遍历属性名
  Object.values() 遍历属性值
  Object.entries() 遍历键值对，以数组形式返回

  （6）扩展运算符( ... )
  
  扩展运算符一定是最后一个参数，而且解构的一定要为对象（null和undefined报错）

  解构赋值的拷贝为浅拷贝，如果是拷贝的键的值是对象、函数、数组，那么将拷贝这个值的引用（修改会反映出来），且不会拷贝它的原型属性

  可以合并两个对象
