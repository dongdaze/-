    了解执行上下文要知道执行上下文的准备工作步骤。

  准备工作，当执行环境中有：

  1. .变量、函数表达式的时候，会进行变量声明，默认赋值undefined

  2.this，默认赋值

  3.函数声明，直接赋值

    也就是在代码执行之前，有的声明赋值undefined，有的直接赋值，而每进行一次函数调用，都会产生一个执行上下文的环境

  this指向，this指向我有一篇文章说了，现在就再简单说一下比较好记的方法；this要么指向window，要么指向一个对象。其实this

    指向对象分为两种情况，一种是构造函数new出来一个实例，用实例调用构造函数中 this属性，那么this就指向那个new出来的实例对象；第二种是
  作为一个对象的方法存在默认指向该对象，但是调用这个对象的方法时候，不要再声明别的变量保存，要不然会指向window；如果要是声明变量保存了，
  也可以用call、apply来改变this指向；剩下的this都指向window，全局环境，这个比较好记。

    明白了执行上下文，就引出了作用域这个概念，JS中没有跨级作用域（ES6例外），但是有函数作用域，当每次进行函数调用的时候都会产生一个执行
 上下文，而不同的函数调用带来的执行上下文环境中变量的值也会不同；

    明白作用域，就该知道作用域中如何取值，作用域在函数创建的时候就已经定义了，而不是函数调用时候再去定义；通常情况下，当执行完该执行环境后，
  就要销毁该环境。但是有一种情况却不可以，那就是闭包；

    理解闭包要说几个简单的概念，一个就是作用域取值，那作用域取值不就是往上找，自己有就用，没有就找自由变量吗？不严谨，其实要到创建该函数的
  那个执行上下文环境中找变量的值。一定是当前执行环境。

    闭包应用场景一般是作为函数返回，还有作为参数；闭包能够引发内存侧漏就是因为它再应该销毁的时候，它还用着别的变量，且作为函数返回的时候
  又创建了一个独立的函数作用域；所以之前我用闭包做的测试，值就能保留下来；

    简单总结下：执行上下文有准备工作，而作用域其实和执行上下文不一样，作用域在创建函数的时候就有了，当进入一个执行环境的时候，就会访问对
  应的作用域，再从当前作用域中取值；当函数作为返回值时，就会创建一个独立的作用域，形成闭包，它就会被保存下来了，不会被垃圾回收，以便我们去调用；
